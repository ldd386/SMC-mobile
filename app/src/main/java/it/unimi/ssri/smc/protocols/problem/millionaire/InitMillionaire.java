package it.unimi.ssri.smc.protocols.problem.millionaire;

import java.math.BigInteger;
import java.util.Random;

import it.unimi.ssri.smc.protocols.RSAIntegers;
import it.unimi.ssri.smc.protocols.SMCProtocolPacket;
import it.unimi.ssri.smc.protocols.problem.InitUser;

/**
 * Sia R_a la ricchezza di alice ed R_b la ricchezza di Bob
 * 
 * * * FASE 1 * * * 
 * 
 * Alice sceglie un numero casuale "x" abbastanza grande e lo cifra con la chiave pubblica
 * di Bob c = E_b(x), in seguito calcola Val_a = c - R_a e manda tale valore a Bob
 * 
 * * * FASE 2 * * * 
 * 
 * Bob computa i seguenti 100 numeri: 
 * 								y_u = D_b(Val_a+u) per 1<= u<=100,
 * dove D_b e' l'algoritmo di decifratura che utilizza la chiave privata di Bob.
 * In seguito sceglie un primo "p" grande in maniera casuale e computa i seguenti 100 numeri:
 * z_u = y_u mod p per 1 <= u <= 100 poi verifica che 
 * per ogni u != v si ha che:
 * 								|z_u - z_v| >= 2
 * per ogni u:
 * 								0< z_u < (p-1)
 * Se cioe' non e' vero Bob sceglie un altro primo e ricomincia.
 * Alla fine Bob manda ad Alice questi numeri in questo esatto ordine:
 * 
 * 	z_1, z_2,...,z_j, z_{j+1}+1,z_{j+2}+1,..., z_100+1, p
 * 
 * * * FASE 3 * * * 
 * 
 * Alice controlla se il numero i-esimo nella sequenza e' congruo a x mod p.
 * Se lo e' R_a <= R_b altrimenti R_b > R_a.
 * Alice comunica il risultato a Bob.
 * 
 * * * FASE 4 * * *
 * 
 * Bob conosce il risultato.
 * 
 * @author k.m.
 *
 */
public class InitMillionaire implements InitUser {
	
	// Alice secret random number (autogenerated if no present)
	private BigInteger x;
	// Riches $$
	private BigInteger r;
	// B keys
	private BigInteger E_b;
	private BigInteger mod_b;
	// dim_u, default 100
	private int dim_u = 100;
	// result
	private boolean imRicherValue= false;
	
	private SMCProtocolPacket lastPacket = null;

	public InitMillionaire(BigInteger r) {
        if(r.intValue() > dim_u)
            throw new IllegalArgumentException("Richness must be < of the max value (" + dim_u + ")" );
        this.r = r;
	}

    public InitMillionaire(BigInteger r, int dim_u) {
        if(r.intValue() > dim_u)
            throw new IllegalArgumentException("Richness must be < of the max value (" + dim_u + ")" );
        this.r = r;
        this.dim_u = dim_u;
    }

	@Override
	public SMCProtocolPacket generateNextPacket(SMCProtocolPacket packetReceived){
		switch (packetReceived.getPhaseint()) {
			case 0:
				throw new IllegalArgumentException("Please call generateInitializationPacket() for this phase");
			case 1:
				throw new IllegalArgumentException("1 is a Wrong phase for init user!");
			case 2:
				return generatePhase3Packet( packetReceived);
			default:
				throw new IllegalArgumentException("Wrong phase for this protocol!");
		}
	}

	@Override
	public boolean hasNextPacket(SMCProtocolPacket packetReceived) {
		return packetReceived.getPhaseint()<3;
	}

    @Override
    public String getVerboseResult(SMCProtocolPacket packetWithResult) {
        return imRicher()? "I'm richer" : "I'm poorest";
    }

    @Override
    public int getGroupSize() {
        return 2;
    }

    @Override
    public boolean isSecured(){
        return true;
    }
    /*
         * generate initialization packet
         */
	@Override
	public SMCProtocolPacket generateInitializationPacket(){
        if(r == null || E_b == null || mod_b == null){
            throw new IllegalArgumentException("r or E_b or mod_b is null");
        }
		SMCProtocolPacket smcProtocolPacket = new SMCProtocolPacket();
		smcProtocolPacket.setPhaseint(1);
		// x is a very large number
		if(x == null)
			x = new BigInteger(256, new Random());
		RSAIntegers rsaCypherToBob = new RSAIntegers(mod_b, E_b);
		BigInteger c = rsaCypherToBob.encrypt(x);
		BigInteger val_a = c.subtract(r);
		smcProtocolPacket.getValues().add(0,val_a);
		return smcProtocolPacket;
	}

	private SMCProtocolPacket generatePhase3Packet(SMCProtocolPacket phase2Packet){
		if(r== null || x == null){
            throw new IllegalArgumentException("r or x is null");
        }
		if(phase2Packet.getValues().size() != dim_u+1){
            throw new IllegalArgumentException("phase2Packet.getValues().size() != dim_u+1");
        }
		SMCProtocolPacket phase3packet = new SMCProtocolPacket();
		BigInteger p = phase2Packet.getValues().get(dim_u);
		if(!x.mod(p).equals(phase2Packet.getValues().get(r.intValue()-1))){
			phase3packet.getValues().add(BigInteger.ZERO);
			imRicherValue = true;
		} else{
			phase3packet.getValues().add(BigInteger.ONE);
			imRicherValue = false;
		}
		phase3packet.setPhaseint(3);
		phase3packet.setLastPacket(true);
		// saving last packet for futures uses
		lastPacket = phase3packet;
		return phase3packet;
	}
	
	public boolean imRicher() {
		return imRicherValue;
	}
	
	public void setB_pubkey(BigInteger E_b, BigInteger mod_b) {
		this.E_b = E_b;
		this.mod_b = mod_b;
	}

	public void setX(BigInteger x){
		this.x = x;
	}

	@Override
	public SMCProtocolPacket getResponsePacket() {
		return lastPacket;
	}
}
